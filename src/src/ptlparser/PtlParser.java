/* Generated By:JavaCC: Do not edit this line. PtlParser.java */
package ptlparser;

import lib.*;
import java.util.HashMap;
import java.util.Map;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.File;
import aux.Comandos;

public class PtlParser implements PtlParserConstants {
  private Protocol p;

  private boolean protocolPart;
  private String statePrefix;
  private String stateSufix;
  private Map<String, Participant> participantMap;
  private Map<String, State> mapState;

  private Map<String, Participant> map;
  private State stateFrom;
  private State stateTo;
  private int level;

  private boolean thereIsInitialState = false;
  private boolean thereIsFinalState = false;
  private boolean deliver = true;

  private PtlParser parser;

  public static Protocol loadProtocol(String file) throws Exception {
        Protocol temp = PtlParser.loadComposedProtocol(file, null, null, null, null, 0);

        if (temp == null)
                throw new Error("Compiler error.");

        temp.setSpecification(Comandos.loadFile(file));
        return temp;
  }

  public void setParser(PtlParser parser) {
        this.parser = parser;
  }

  public void setProtocol(Protocol p) {
        this.p = p;
  }

  public Protocol getProtocol() {
    if (deliver)
                return p;
        return null;
  }

  public static Protocol loadComposedProtocol(String file, Protocol p, Map<String, Participant> map, State stateFrom, State stateTo, int level)  throws ParseException {
        InputStream input;
        try {
                input = new FileInputStream(file);
                PtlParser parserCmp = new PtlParser(input);
                parserCmp.setParser(parserCmp);
                parserCmp.setProtocol(p);
                boolean success = parserCmp.loadComposedProtocol(map, stateFrom, stateTo, level);
                if (success)
                        return parserCmp.getProtocol();
                else
                        return null;
        } catch (FileNotFoundException e1) {
                e1.printStackTrace();
        }
        return null;
  }

  public boolean loadComposedProtocol(Map<String, Participant> map, State stateFrom, State stateTo, int level)  throws ParseException {
        protocolPart = stateFrom != null;
        participantMap = new HashMap<String, Participant>();
        if (stateFrom == null) {
                stateSufix = "";
                statePrefix = "";
        } else {
                stateSufix = "[" + stateFrom.getId() + "]";
                statePrefix = "";
                protocolPart = true;
        }
        mapState = new HashMap<String, State>();

        this.map = map;
        this.stateFrom = stateFrom;
        this.stateTo = stateTo;
        this.level = level;

          try
          {
            Protocol xp = parser.protocol();
            return deliver;
          }
          catch (Exception e)
          {
            System.out.println("Compiler error. " + level);
            System.out.println(e.getMessage());
          }
          catch (Error e)
          {
            System.out.println("Compiler error. " + level);
            System.out.println(e.getMessage());
          }
          return false;
  }

  public static void main(String args []) throws Exception
  {
      if (args.length < 1) {
          System.out.println("Inform the protocol file to compile.");
      } else {
          loadProtocol(args[0]);
      }
  }

        private boolean validateCardinalityConsistence(Participant participant, String transitionCard) {
                if (transitionCard.equals(""))
                        return true;

                String participantCard;

                if (participant.getqMax() == null)
                        participantCard = String.valueOf(participant.getMax());
                else
                        participantCard = participant.getqMax();

                return validateCardinalityConsistence(participantCard, transitionCard);
        }

        private boolean validateCardinalityConsistence(String max, String min) {
                if (min.equals(""))
                        return true;

                if (max.equals("all")) {
                        return true;
                } else if (max.equals("+")) {
                        if (min.equals("all")) {
                                return false;
                        }
                } else {
                        if (min.equals("all")) {
                                return false;
                        } else if (min.equals("+")) {
                                return true;
                        } else {
                                int iMax = Integer.valueOf(max);
                                int iMin = Integer.valueOf(min);
                                if (iMax < iMin)
                                        return false;
                        }
                }

                return true;
        }

        private String unQuote(String str) {
        if (str.charAt(0) == '"' && str.charAt(str.length()-1) == '"' )
                return str.substring(1, str.length()-1);
        return str;
        }

  final public Protocol protocol() throws ParseException {
                       Token name;
    jj_consume_token(TK_PROTOCOL);
    name = jj_consume_token(ID);
                                                if (!protocolPart) {
                                                        p = new Protocol();
                                                        p.setName(name.image);
                                                }
    jj_consume_token(35);
    description();
    goals();
    participants();
    states();
    transitions();
    jj_consume_token(36);
                              {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  final public void transitions() throws ParseException {
    jj_consume_token(TK_TRANSITIONS);
    jj_consume_token(37);
    label_1:
    while (true) {
      transition();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
  }

  final public void transition() throws ParseException {
                     Transition t = new Transition();
                                        String sId;
                                        String dId;
                                        String sIdComplete;
                                        String dIdComplete;
    sId = stateId();
    jj_consume_token(38);
    dId = stateId();
    jj_consume_token(39);
                                        sIdComplete = statePrefix+sId+stateSufix;
                                        dIdComplete = statePrefix+dId+stateSufix;

                                                State s;
                                                State sNew;
                                                if (!protocolPart || (protocolPart && !mapState.containsKey(sIdComplete))) {
                                                        s = p.getStateByName(sIdComplete);
                                                } else {
                                                        //System.out.println("State mapped from " + sIdComplete + " to " + mapState.get(sIdComplete).getId());
                                                        s = mapState.get(sIdComplete);
                                                }
                                                if (s == null) {

                                                        sNew = new State(sIdComplete,
                                                                                                false,
                                                                                                false);
                                                        p.addState(sNew);
                                                        s = sNew;

                                                        //throw new Error("State "+sIdComplete+" does not exist.");
                                                }

                                                if (s.isFinalState()) {
                                                        {if (true) throw new Error("The "+s.getId() +" is a final state. It does not allow transitions");}
                                                }

                                                State d;
                                                if (!protocolPart || (protocolPart && !mapState.containsKey(dIdComplete))) {
                                                        d = p.getStateByName(dIdComplete);
                                                } else {
                                                        d = mapState.get(dIdComplete);
                                                        //System.out.println("State d mapped from " + dIdComplete + " to " + mapState.get(dIdComplete).getId());
                                                }
                                                if (d == null) {

                                                        sNew = new State(dIdComplete,
                                                                                                false,
                                                                                                false);
                                                        p.addState(sNew);
                                                        d = sNew;

                                                        //throw new Error("State "+dIdComplete+" does not exist.");
                                                }

                                                t.setCurrentState(s);
                                                t.setNextState(d);
    transitionType(t);
  }

  final public void transitionType(Transition t) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      occurrence(t);
                                                    t.getCurrentState().addTransition(t);
                                                    p.addTransition(t);
      break;
    case TK_TIMEOUT:
      timeout(t);
      break;
    case TK_IMPORT:
      importt(t);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void timeout(Transition t) throws ParseException {
                              Token timeoutT;
    jj_consume_token(TK_TIMEOUT);
    timeoutT = jj_consume_token(INTEGER);
                                  t.setType(Transition.TIMEOUT);
                                  State s = t.getCurrentState();

                                  if (s.getGotoStateOnTimeout() != null) {
                                      {if (true) throw new Error("Multiple timeout defined for the state " + s.getId() + ".");}
                                  }

                                  State timeoutState = t.getNextState();
                                  s.setTimeout(Long.valueOf(Integer.parseInt(timeoutT.image)));
                                  s.setGotoStateOnTimeout(timeoutState);
                                  s.setTimeoutTransition(t);
    jj_consume_token(40);
  }

  final public void importt(Transition t) throws ParseException {
                              Token fileT;
    jj_consume_token(TK_IMPORT);
    fileT = jj_consume_token(STRING);
    mapping();
                State s = t.getCurrentState();
                State toState = t.getNextState();
                Protocol temp = PtlParser.loadComposedProtocol(unQuote(fileT.image), p, participantMap, s, toState, level+1);
                if (temp == null)
                        deliver = false;
    jj_consume_token(40);
  }

  final public void mapping() throws ParseException {
    jj_consume_token(TK_MAPPING);
    jj_consume_token(35);
    label_2:
    while (true) {
      mapFromTo();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
    }
    jj_consume_token(36);
  }

  final public void mapFromTo() throws ParseException {
                   String from;
                                   String to;
    from = mappingFrom();
    to = mappingTo();
    jj_consume_token(40);
                Participant participantFrom;
                if (!protocolPart || (protocolPart && !map.containsKey(from))) {
                        participantFrom = p.getParticipantByName(from);
                } else {
                        participantFrom = map.get(from);
                }

                if (participantFrom == null) {
                        {if (true) throw new Error("Participant "+from+" does not exist.");}
                }

                participantMap.put(to, participantFrom);
  }

  final public String mappingFrom() throws ParseException {
                        String id;
    id = participantId();
                                            {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

  final public String mappingTo() throws ParseException {
                      String id;
    id = participantId();
                                          {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

  final public void trigger(Transition t) throws ParseException {
                                        String pattern = "";
                                        String content = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_TRIGGER:
      pattern = pattern();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 37:
        content = content();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      break;
    case 37:
      content = content();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(40);
                                  t.addTransitionTrigger(new Trigger(pattern, content));
  }

  final public String pattern() throws ParseException {
                    Token patternT;
    jj_consume_token(TK_TRIGGER);
    patternT = jj_consume_token(STRING);
                                    {if (true) return unQuote(patternT.image);}
    throw new Error("Missing return statement in function");
  }

  final public String content() throws ParseException {
                    Token contentT;
    jj_consume_token(37);
    contentT = jj_consume_token(STRING);
                                    {if (true) return unQuote(contentT.image);}
    throw new Error("Missing return statement in function");
  }

  final public void occurrence(Transition t) throws ParseException {
    participantOccurrence(t, false);
    jj_consume_token(41);
    duty(t);
    jj_consume_token(42);
    participantOccurrence(t, true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_TRIGGER:
    case 37:
      label_3:
      while (true) {
        trigger(t);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TK_TRIGGER:
        case 37:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_3;
        }
      }
      break;
    case 40:
      jj_consume_token(40);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          if (t.getTransitionTriggers().size() == 0)
          {
                t.addTransitionTrigger(new Trigger("", ""));
          }
  }

  final public void duty(Transition t) throws ParseException {
                           Token dutyT;
    dutyType(t);
    dutyT = jj_consume_token(STRING);
                                                   t.setDuty(unQuote(dutyT.image));
  }

  final public void dutyType(Transition t) throws ParseException {
                               Token typeT;
                                                           Token performativeT = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_EVENT:
      typeT = jj_consume_token(TK_EVENT);
      break;
    case TK_ACTION:
      typeT = jj_consume_token(TK_ACTION);
      break;
    case TK_MESSAGE:
      typeT = jj_consume_token(TK_MESSAGE);
      jj_consume_token(43);
      performativeT = jj_consume_token(ID);
      jj_consume_token(44);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          String type = typeT.image;
          if (type.equals("message")) {
                t.setType(Transition.MESSAGE);
          } else if (type.equals("action")) {
                t.setType(Transition.ACTION);
          } else {
            t.setType(Transition.EVENT);
          }

          if (performativeT != null)
                t.setPerformative(performativeT.image);
  }

  final public void participantOccurrence(Transition t, boolean destination) throws ParseException {
                                                          String idPlayer;
                                                          Token cardinalityT = null;
    idPlayer = participantId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 43:
      jj_consume_token(43);
      cardinalityT = jj_consume_token(INTEGER);
      jj_consume_token(44);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                                        Participant e;
                                        if (protocolPart && map.containsKey(idPlayer)) {
                                                e = map.get(idPlayer);
                                        } else {
                                                e = p.getParticipantByName(idPlayer);
                                        }
                                        if (e == null) {
                                                {if (true) throw new Error("Participant "+idPlayer+" does not exist.");}
                                        }
                                        String cardinality;
                                        if (cardinalityT == null)
                                                cardinality = "";
                                        else
                                                cardinality = cardinalityT.image;
                                        if (!validateCardinalityConsistence(e, cardinality)) {
                                                {if (true) throw new Error("There are inconsistence in the cardinality of the " + e.getId() + " with some transition.");}
                                        }

                                        if (destination) {
                                                t.setDestination(e);
                                                if (!cardinality.equals(""))
                                                        t.setCardDestination(Integer.parseInt(cardinality));
                                        } else {
                                                t.setSource(e);
                                                if (!cardinality.equals(""))
                                                        t.setCardSource(Integer.parseInt(cardinality));
                                        }
  }

  final public void states() throws ParseException {
    jj_consume_token(TK_STATES);
    jj_consume_token(37);
    label_4:
    while (true) {
      state();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
    }
                if (!thereIsFinalState) {
                        {if (true) throw new Error("There is no final state in the protocol.");}
                }

                if (!thereIsInitialState) {
                        {if (true) throw new Error("There is no initial state in the protocol.");}
                }
  }

  final public void state() throws ParseException {
                                String idState;
                                Token initialState = null;
                                Token finalState = null;
    idState = stateId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_INITIAL:
    case TK_FINAL:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_INITIAL:
        initialState = jj_consume_token(TK_INITIAL);
        break;
      case TK_FINAL:
        finalState = jj_consume_token(TK_FINAL);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    jj_consume_token(40);
        if (!protocolPart || (protocolPart && initialState == null && finalState == null)) {
                State s = new State(statePrefix+idState+stateSufix,
                                                initialState != null,
                                                finalState != null);

                if (s.isFinalState())
                        thereIsFinalState = true;

                if (s.isInitialState())
                        thereIsInitialState = true;

                p.addState(s);
        } else {
                if (initialState != null) {
                        mapState.put(statePrefix+idState+stateSufix, stateFrom);
                        thereIsInitialState = true;
                }

                if (finalState != null) {
                        mapState.put(statePrefix+idState+stateSufix, stateTo);
                        thereIsFinalState = true;
                }
        }
  }

  final public String stateId() throws ParseException {
                    Token idState;
    idState = jj_consume_token(ID);
                                    {if (true) return idState.image;}
    throw new Error("Missing return statement in function");
  }

  final public void participants() throws ParseException {
    jj_consume_token(TK_PARTICIPANTS);
    jj_consume_token(37);
    label_5:
    while (true) {
      participant();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_5;
      }
    }
  }

  final public void participant() throws ParseException {
                      String id;
                                          String kind;
                                          String roleORtype;
                                          String min = "1";
                                          String max = "1";

                                          Token kindT;
    id = participantId();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_AGENT:
      kindT = jj_consume_token(TK_AGENT);
      roleORtype = role();
      break;
    case TK_ARTIFACT:
      kindT = jj_consume_token(TK_ARTIFACT);
      roleORtype = type();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_ALL:
      max = participantCardinalityAll();
      break;
    default:
      jj_la1[16] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_MIN:
        min = participantCardinalityMin();
                          max = "+";
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TK_MAX:
        max = participantCardinalityMax();
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
    }
    jj_consume_token(40);
            if (!validateCardinalityConsistence(max,min)) {
                {if (true) throw new Error("Invalid cardinality for participant " + id + ".");}
            }
                kind = kindT.image;
                if (!protocolPart || (protocolPart && !map.containsKey(id) && p.getParticipantByName(id) == null)) {
                        Participant participant;
                        if (max.equals("all") || max.equals("+")) {
                                participant = new Participant(id, roleORtype, kind, Integer.parseInt(min), max);
                        } else {
                                participant = new Participant(id, roleORtype, kind, Integer.parseInt(min), Integer.valueOf(max));
                        }

                        p.addParticipant(participant);
                }
  }

  final public String participantId() throws ParseException {
                          Token id;
    id = jj_consume_token(ID);
                                                  {if (true) return id.image;}
    throw new Error("Missing return statement in function");
  }

  final public String type() throws ParseException {
                 Token type;
    type = jj_consume_token(STRING);
                             {if (true) return unQuote(type.image);}
    throw new Error("Missing return statement in function");
  }

  final public String role() throws ParseException {
                 Token role;
    role = jj_consume_token(STRING);
                             {if (true) return unQuote(role.image);}
    throw new Error("Missing return statement in function");
  }

  final public String participantCardinalityMin() throws ParseException {
                                      Token min;
    jj_consume_token(TK_MIN);
    min = jj_consume_token(INTEGER);
                                                                           {if (true) return min.image;}
    throw new Error("Missing return statement in function");
  }

  final public String participantCardinalityMax() throws ParseException {
                                      Token max;
    jj_consume_token(TK_MAX);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      max = jj_consume_token(INTEGER);
      break;
    case TK_PLUS:
      max = jj_consume_token(TK_PLUS);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                                          {if (true) return max.image;}
    throw new Error("Missing return statement in function");
  }

  final public String participantCardinalityAll() throws ParseException {
                                      Token max;
    max = jj_consume_token(TK_ALL);
                                                                          {if (true) return max.image;}
    throw new Error("Missing return statement in function");
  }

  final public void description() throws ParseException {
                      Token description;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TK_DESCRIPTION:
      jj_consume_token(TK_DESCRIPTION);
      jj_consume_token(37);
      description = jj_consume_token(STRING);
                                                                 if (!protocolPart) {
                                                                         p.setDescription(unQuote(description.image));
                                                         }
      jj_consume_token(40);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
  }

  final public void goals() throws ParseException {
                String goal;
    jj_consume_token(TK_GOALS);
    jj_consume_token(37);
    label_6:
    while (true) {
      goal = goal();
                                if (!protocolPart) {
                                                p.addAchieveGoal(new Goal(goal));
                                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_6;
      }
    }
  }

  final public String goal() throws ParseException {
                 Token goal;
    goal = jj_consume_token(STRING);
    jj_consume_token(40);
                             {if (true) return unQuote(goal.image);}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public PtlParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x40000000,0x41080000,0x40000000,0x0,0x800000,0x800000,0x800000,0x700000,0x0,0x40000000,0x30000,0x30000,0x40000000,0x1800,0x4000,0x2000,0x4000000,0x18000000,0x100,0x20000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x20,0x20,0x20,0x120,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public PtlParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public PtlParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PtlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public PtlParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PtlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public PtlParser(PtlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(PtlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[45];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 45; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
